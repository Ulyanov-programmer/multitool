"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.lutimesSync = exports.lutimes = exports.utimesSync = exports.utimes = void 0;
let _fsResolved;
let _pathResolved;
let _bindingResolved;
/**
 * Wrapper on the `require` function to trick bundlers and avoid including mapbox dependencies.
 *
 * @param name
 * @returns
 */
const __require = (name) => require(name);
/**
 * Resolves the `fs` module and caches it.
 *
 * @returns
 */
function fs() {
    if (!_fsResolved) {
        _fsResolved = __require('fs');
    }
    return _fsResolved;
}
/**
 * Resolves the `path` module and caches it.
 *
 * @returns
 */
function path() {
    if (!_pathResolved) {
        _pathResolved = __require('path');
    }
    return _pathResolved;
}
/**
 * The native addon binding.
 */
function nativeAddon() {
    if (_bindingResolved === undefined) {
        const gyp = __require('@mapbox/node-pre-gyp');
        const packagePath = path().resolve(path().join(__dirname, '../package.json'));
        const addonPath = gyp.find(packagePath);
        if (!fs().existsSync(addonPath)) {
            return _bindingResolved = null;
        }
        _bindingResolved = __require(addonPath);
    }
    return _bindingResolved;
}
;
/**
 * Whether or not the current platform supports the native addon.
 */
function useNativeAddon() {
    if (typeof process !== 'undefined' && ['darwin', 'win32', 'linux'].indexOf(process.platform) >= 0) {
        if (_bindingResolved === undefined) {
            nativeAddon();
        }
        if (_bindingResolved === null) {
            return false;
        }
        return true;
    }
    return false;
}
function utimes(path, options, callback) {
    return invokeWrapped(path, options, true, callback);
}
exports.utimes = utimes;
/**
 * Synchronously updates the timestamps on the given path(s).
 *
 * @param path
 * @param options
 */
function utimesSync(path, options) {
    return invokeUTimesSync(path, options, true);
}
exports.utimesSync = utimesSync;
function lutimes(path, options, callback) {
    return invokeWrapped(path, options, false, callback);
}
exports.lutimes = lutimes;
/**
 * Synchronously updates the timestamps on the given path(s).
 *
 * @param path
 * @param options
 */
function lutimesSync(path, options) {
    return invokeUTimesSync(path, options, false);
}
exports.lutimesSync = lutimesSync;
/**
 * Invokes utimes with the given options, and implements callbacks/promises based on the parameters.
 *
 * @param path
 * @param options
 * @param resolveLinks
 * @param callback
 * @returns
 */
function invokeWrapped(path, options, resolveLinks, callback) {
    if (typeof callback === 'function') {
        return invokeUTimes(path, options, resolveLinks, callback);
    }
    else {
        return new Promise((resolve, reject) => {
            invokeUTimes(path, options, resolveLinks, error => {
                if (typeof error !== 'undefined') {
                    reject(error);
                }
                else {
                    resolve();
                }
            });
        });
    }
}
/**
 * Invokes utimes with the given options.
 *
 * @param path A string path or an array of string paths.
 * @param options The timestamps to use.
 * @param resolveLinks Whether or not to resolve symbolic links and update their target file instead.
 * @param callback Function to invoke when completed.
 * @returns
 */
function invokeUTimes(path, options, resolveLinks, callback) {
    if (typeof process === 'undefined') {
        return callback();
    }
    const targets = getNormalizedPaths(path);
    const times = getNormalizedOptions(options);
    const flags = getFlags(times);
    const invokeAtIndex = (index) => {
        const target = targets[index];
        if (target === undefined) {
            return callback();
        }
        // Invoke the native addon on supported platforms
        if (useNativeAddon()) {
            invokeBindingAsync(target, times, flags, resolveLinks, error => error !== undefined ? callback(error) : invokeAtIndex(index + 1));
        }
        // Fall back to using `fs.utimes` for other platforms
        else {
            fs()[resolveLinks ? 'stat' : 'lstat'](target, (statsErr, stats) => {
                if (statsErr)
                    return callback(statsErr);
                fs()[resolveLinks ? 'utimes' : 'lutimes'](target, (flags & 4 ? times.atime : stats.atime.getTime()) / 1000, (flags & 2 ? times.mtime : stats.mtime.getTime()) / 1000, error => error ? callback(error) : invokeAtIndex(index + 1));
            });
        }
    };
    // Return if there's nothing to do
    if (!flags || !targets.length) {
        return callback();
    }
    // Start setting timestamps
    invokeAtIndex(0);
}
/**
 * Invokes utimes synchronously with the given options.
 *
 * @param path A string path or an array of string paths.
 * @param options The timestamps to use.
 * @param resolveLinks Whether or not to resolve symbolic links and update their target file instead.
 * @returns
 */
function invokeUTimesSync(path, options, resolveLinks) {
    if (typeof process === 'undefined') {
        return;
    }
    const targets = getNormalizedPaths(path);
    const times = getNormalizedOptions(options);
    const flags = getFlags(times);
    const invokeAtIndex = (index) => {
        const target = targets[index];
        if (target === undefined) {
            return;
        }
        // Invoke the native addon on supported platforms
        if (useNativeAddon()) {
            invokeBindingSync(target, times, flags, resolveLinks);
            invokeAtIndex(index + 1);
        }
        // Fall back to using `fs.utimes` for other platforms
        else {
            const stats = fs()[resolveLinks ? 'statSync' : 'lstatSync'](target);
            fs()[resolveLinks ? 'utimesSync' : 'lutimesSync'](target, (flags & 4 ? times.atime : stats.atime.getTime()) / 1000, (flags & 2 ? times.mtime : stats.mtime.getTime()) / 1000);
            invokeAtIndex(index + 1);
        }
    };
    // Return if there's nothing to do
    if (!flags || !targets.length) {
        return;
    }
    // Start setting timestamps
    invokeAtIndex(0);
}
/**
 * Converts the given string or string array into a guaranteed array of strings.
 *
 * @param paths
 */
function getNormalizedPaths(paths) {
    if (typeof paths === 'string') {
        assertPath('path', paths);
        return [paths];
    }
    if (Array.isArray(paths)) {
        for (let i = 0; i < paths.length; i++) {
            const path = paths[i];
            assertPath(`paths[${i}]`, path);
        }
        return paths;
    }
    throw new Error('Path must be a string or array');
}
/**
 * Replaces missing options with zero values.
 *
 * @param options
 */
function getNormalizedOptions(options) {
    if (typeof options === 'number') {
        options = {
            btime: options,
            mtime: options,
            atime: options
        };
    }
    if (options instanceof Date) {
        options = {
            btime: options.getTime(),
            mtime: options.getTime(),
            atime: options.getTime()
        };
    }
    if (typeof options === 'undefined' || options === null) {
        options = {
            btime: 0,
            mtime: 0,
            atime: 0
        };
    }
    if (typeof options !== 'object') {
        throw new Error('Options must be an object');
    }
    const btime = getTime('btime', options.btime);
    const mtime = getTime('mtime', options.mtime);
    const atime = getTime('atime', options.atime);
    assertTimestamp('btime', btime);
    assertTimestamp('mtime', mtime);
    assertTimestamp('atime', atime);
    return {
        btime: btime || 0,
        mtime: mtime || 0,
        atime: atime || 0
    };
}
/**
 * Converts a time input into a timestamp number.
 *
 * @param key
 * @param input
 * @returns
 */
function getTime(key, input) {
    if (typeof input === 'number' || typeof input === 'undefined') {
        return input;
    }
    if (typeof input === 'object' && typeof input.getTime === 'function') {
        return input.getTime();
    }
    throw new Error(key + ' must be a number or Date');
}
/**
 * Calculates the flags to send to the binding.
 *
 * @param options
 */
function getFlags(options) {
    let flags = 0;
    if (options.btime)
        flags |= 1;
    if (options.mtime)
        flags |= 2;
    if (options.atime)
        flags |= 4;
    return flags;
}
/**
 * Calls the binding and invokes a callback function.
 *
 * @param path
 * @param times
 * @param flags
 */
function invokeBindingAsync(path, times, flags, resolveLinks, callback) {
    nativeAddon().utimes(getPathBuffer(path), flags, times.btime, times.mtime, times.atime, resolveLinks, (result) => {
        if (typeof result !== 'undefined') {
            const name = resolveLinks ? 'utimes' : 'lutimes';
            const message = result.message.trim().replace(/\.$/, '');
            callback(new Error(`${message}, ${name} '${path}'`));
            return;
        }
        callback();
    });
}
/**
 * Calls the binding synchronously.
 *
 * @param path
 * @param times
 * @param flags
 */
function invokeBindingSync(path, times, flags, resolveLinks) {
    try {
        nativeAddon().utimesSync(getPathBuffer(path), flags, times.btime, times.mtime, times.atime, resolveLinks);
    }
    catch (error) {
        const name = resolveLinks ? 'utimes' : 'lutimes';
        const message = error.message.trim().replace(/\.$/, '');
        throw new Error(`${message}, ${name} '${path}'`);
    }
}
/**
 * Converts a path string into a buffer.
 *
 * @param target
 * @returns
 */
function getPathBuffer(target) {
    const targetLong = path()._makeLong(target);
    const buffer = Buffer.alloc(Buffer.byteLength(targetLong, 'utf-8') + 1);
    buffer.write(targetLong, 0, buffer.length - 1, 'utf-8');
    buffer[buffer.length - 1] = 0;
    if (buffer.indexOf(0) !== buffer.length - 1) {
        throw new Error('Path must be a string without null bytes');
    }
    return buffer;
}
/**
 * @param key
 * @param value
 */
function assertPath(key, value) {
    if (typeof value !== 'string') {
        throw new Error(key + ' must be a string');
    }
    if (value.length === 0) {
        throw new Error(key + ' must not be empty');
    }
    if (value.indexOf('\u0000') !== -1) {
        throw new Error(key + ' must be a string without null bytes');
    }
}
function assertTimestamp(key, value) {
    if (value === undefined) {
        return;
    }
    if (typeof value !== 'number') {
        throw new Error(key + ' must be a number or undefined');
    }
    if (Math.floor(value) !== value) {
        throw new Error(key + ' must be an integer');
    }
    if (value < 0) {
        throw new Error(key + ' must be a positive integer');
    }
    if (value > Math.pow(2, 48) - 1) {
        throw new Error(key + ' must not be more than ' + (Math.pow(2, 48) - 1));
    }
}
//# sourceMappingURL=main.js.map